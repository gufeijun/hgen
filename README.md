![github](https://img.shields.io/github/license/gufeijun/hgen) [![Build Status](https://app.travis-ci.com/gufeijun/hgen.svg?branch=master)](https://app.travis-ci.com/gufeijun/hgen)

# 相关

搭配以下RPC库使用：

+ Go：https://github.com/gufeijun/rpch-go
+ C：https://github.com/gufeijun/rpch-c
+ Node：https://github.com/gufeijun/rpch-node

# 介绍

不同编程语言有不同的语法规则，甚至有的语言有自己独有的序列化方式，如golang的gob、python的pickle等。如果想开发一个跨语言的RPC框架，就必须屏蔽掉不同语言之间的区别，提供一种统一的网络协议格式、对象序列化方法以及接口描述方式。

因此IDL(接口描述语言)的概念应运而生，比如google推出的protobuf。IDL就需要做到统一描述我们欲提供的服务接口，让所有语言都遵循接口定义的规则，由编译器完成IDL到某个具体语言的本土化编译工作。

本着造轮子学习的态度，我并没有为自己的框架选择已经开源成熟的IDL，而是自己设计了一个简单的IDL语言，并为其开发了一个简陋的编译器，也就是本项目hgen，目前已经完成了由IDL编译到golang的工作。编译器前端使用有限状态机，后端采用了golang的模板引擎。目前还未给自己设计的IDL语言命名，暂且每个IDL文件以gfj(作者名字缩写)为文件后缀。

目前hgen生成的代码和其服务的rpc框架rpch存在极高的耦合，后期应该让各个功能模块细度更高，达到解耦。

# IDL语法

### quickstart

新建math.gfj文件：

```protobuf
service Math{
    int32 Add(int32,int32)
}
```

我们定义了一个接口服务Math，这个服务目前仅提供一个Add方法。

利用hgen编译：`hgen -dir gfj -lang go math.gfj`即可在gfj目录下生成golang语言的源码文件`math.rpch.go`：

```go
// This is code generated by hgen. DO NOT EDIT!!!
// hgen version: v0.1.0
// source: math.gfj

package gfj

import (
    rpch "github.com/gufeijun/rpch-go"
)

type MathService interface{
	Add(int32, int32) (int32, error)
}

func RegisterMathService(impl MathService, svr *rpch.Server) {
	methods := map[string]*rpch.MethodDesc {
        "Add": rpch.BuildMethodDesc(impl, "Add", "int32"),
	}
	service := &rpch.Service{
		Impl:    impl,
        Name:    "Math",
		Methods: methods,
	}
	svr.Register(service)
}

type MathServiceClient struct{
    client *rpch.Client
}

func NewMathServiceClient(client *rpch.Client) *MathServiceClient {
    return &MathServiceClient{
		client: client,
	}
}

func (c *MathServiceClient) Add(arg1 int32, arg2 int32) (res int32, err error) {
    resp, err := c.client.Call("Math", "Add",
		&rpch.RequestArg{
            TypeKind: 0,
            TypeName: "int32",
            Data:     arg1,
		},
		&rpch.RequestArg{
            TypeKind: 0,
            TypeName: "int32",
            Data:     arg2,
		})
	if resp == nil {
		return
	}
	return resp.(int32),err
}
```

在该生成的文件中定义了我们服务的接口以及注册服务的函数，除此之外还定义了客户端调用的方法。我们只需要为`MathService`实现具体的Add方法就可以快速实现rpc服务端以及客户端：

```go
package main

import (
	"example/quickstart/gfj"
	"fmt"
	"log"
	"time"

	rpch "github.com/gufeijun/rpch-go"
)

type mathService struct{}

func (*mathService) Add(a int32, b int32) (int32, error) {
	return a + b, nil
}

func startServer() {
	svr := rpch.NewServer()
	gfj.RegisterMathService(new(mathService), svr)
	panic(svr.ListenAndServe("127.0.0.1:8080"))
}

func main() {
	go startServer()
	time.Sleep(time.Second)

	//客户端
	conn, err := rpch.Dial("127.0.0.1:8080")
	if err != nil {
		panic(err)
	}
    defer conn.Close()
	client := gfj.NewMathServiceClient(conn)
	result, err := client.Add(2, 3)
	if err != nil {
		panic(err)
	}
	if result != 5 {
		log.Panicf("want %d, but got %d\n", 5, result)
	}
	fmt.Println("test success!")
}
```

详细实现代码见[链接](https://github.com/gufeijun/rpch-go/tree/master/examples/quickstart)。

### 内置类型

IDL内置了丰富的基本类型：int8、uint8、int16、uint16、int32、uint32、int64、uint64、float32、float64、string、void、stream、istream、ostream。

大部分类型比较好理解，主要讲讲几个特殊的类型。

其中void代表无返回值或者无参数，当接口方法的参数是void，则代表这个方法不需要传入参数。当接口方法的返回值为void，则代表这个方法没有返回值。这点很类似于c语言。

stream类型是我的rpc框架的原创类型，代表了一个流。istream是读取流，对应golang的io.Reader；ostream是写入流，对应golang的io.Writer；stream是读写流，对应golang的io.ReadWriter。不论是哪种stream都可以作为参数传入方法，或者返回参数返回。比如服务端open一个文件得到一个stream流，它可以直接将此stream流返回给客户端，客户端可以如同读写本地文件一样对服务器的这个文件进行读写操作。当然客户端拿到的是经过封装后的，客户端看似在直接读取服务端文件，实际上底层还是在读写tcp连接，只是因为封装给你屏蔽了传输细节，你难以感知而已。

流的实现用到了http协议中的chunk编码。具体使用案例：

比如我们定义IDL文件：

```protobuf
service File{
    stream OpenFile(string)
}
```

服务端实现该接口，其功能就是把这个文件流返回给客户端：

```go
func (*fileService) OpenFile(filepath string) (stream io.ReadWriter, onFinish func(), err error) {
	file, err := os.OpenFile(filepath, os.O_CREATE|os.O_RDWR|os.O_APPEND, 0666)
	if err != nil {
		return
	}
	return file, func() {
		file.Close()
	}, nil
}
```

客户端调用：

```go
func readSomething(client *gfj.FileServiceClient) error {
	file, err := client.OpenFile("test.txt")
	if err != nil {
		return err
	}
	defer file.Close()
	io.Copy(os.Stdout, file)
	return err
}

func writeSomething(client *gfj.FileServiceClient) error {
	file, err := client.OpenFile("test.txt")
	if err != nil {
		return err
	}
	defer file.Close()
	_, err = file.Write([]byte("hello world\n"))
	if err != nil {
	}
	return err
}
```

FileServiceClient是hgen编译器自动生成的类型，我们可以使用NewFileServiceClient就可以将rpch.Client类型转化为此类型，这些代码这里省略。

客户端调用的OpenFile方法隐藏了底层的网络传输细节，客户端并无法感知我们读写的file是一个远在服务器上的文件，而感觉操纵的是一个本地文件。

具体使用可以查看：[链接](https://github.com/gufeijun/rpch-go/tree/master/examples/fileserver)。

###  关键字

目前仅存在两个关键字：message以及service。

service在前面已经有了初识，它用于定义我们的服务接口，服务端代码对照接口的每个方法予以具体实现，客户端根据这个接口的定义进行远程调用。

message用于定义我们通信过程中传输的参数，案例如下 :

```protobuf
service Math{
    uint32 Add(TwoNum)
    Quotient Divide(uint32,uint32)
    //void PrintServiceName(void)
}

message Quotient{
    uint64 Quo	//商
    uint64 Rem	//余数
}

message TwoNum{
    int32 A
    int32 B
}
```

我们定义了两个复合结构Quotient以及TwoNum，复合结构既可作为传入参数又可以作为返回值。除此之外，复合结构内部成员也可以是复合结构，没有限制规则。

### 注意事项

#### 接口方法的定义

1. 对于Go语言来说，最好将服务名、复合结构名以及复合结构成员首字母大小表示，否则你只能在所生成的代码文件包下编写对应的实现，会带来一定麻烦。
2. 多个service尽量放在不同的.gfj后缀的IDL文件中。
3. 如果方法无返回值，则让返回值为void；如果方法不需要传入参数，则必须填入void显示地表示该方法无参数。如`void Print(void)`，该方法就无参数且无返回值。

# 协议设计

### 协议

传输层采用TCP，应用层协议单独设计，支持长连接。

客户端发起TCP连接后，需要完成握手过程：客户端发送4B的小端魔数(0x00686A6C)。如果服务端未正确接受到魔数，则断开TCP连接。

以IDL定义Add服务为例：

```go
service Math{
	uint32 Add(uint32,uint32)
}
```

客户端发送请求报文：

```
//第一行为请求行
Math Add 2 1\r\n //分别对应服务名 方法名 请求参数个数 请求的序号
TypeKind(2B) TypeNameLength(2B) DataLength(4B) TypeName Data //第一个参数
TypeKind(2B) TypeNameLength(2B) DataLength(4B) TypeName Data //第二个参数
```

请求序号方便用于开发异步请求客户端。使用TLV方式解决粘包问题，使用**小端方式**传输Type以及长度。TypeName为参数的类型(字符串方式)，Data为序列化后的数据。

服务端的响应报文：

```
Sequence(8B) TypeKind(2B) TypeNameLength(2B) DataLength(4B) TypeName Data
```

和客户端请求报文参数大同小异，不过多了8B的请求序号。

### 序列化

框架支持传输四种类型：

+ string

+ int32、uint32等能确定位长的Number数字类型。

+ 复合类型，即用message定义的类型。

+ Stream流类型。string类型不需要做序列化，数字类型采用小端方式即可，复合类型使用json传输，stream流类型使用
  http1.1引入的chunk编码实现。

string类型不需要做序列化，数字类型采用小端方式即可，复合类型使用json传输，stream流类型使用http1.1引入的chunk编码实现。

stream类型为本框架独创类型，能够让客户端宛如操纵本地文件一样操纵服务端的文件句柄。使用案例：

定义IDL服务：

```protobuf
service File{
	stream OpenFile(string)
}
```

服务端实现服务：

```go
//将本地的文件句柄直接返回
func (*fileServer) OpenFile(filepath string)(stream io.ReadWriter, OnFinish
func(), err error){
    file, err := os.OpenFile(filepath, os.O_CREATE|os.O_RDWR|os.O_APPEND, 0666)
    if err !=nil{
    	return
    }
    return file, func(){
    	file.Close()
    },nil
}
```

客户端调用服务：

```go
file, err := client.OpenFile("text.txt")
if err != nil{
panic(err)
}
defer file.Close()
//....
//对file读写操作(省略)
```

不论怎么封装，最终都是落实到tcp连接的读取，我们使用chunk编码隐藏了这个过程。示意图如下：

![image.png](https://s2.loli.net/2022/03/15/dfMLIPbaD2uBW7x.png)

服务端和客户端与tcp连接直接都存在一层中间件：

+ 从tcp连接读时，自动将chunk编码数据转化为payload。

+ 往tcp连接写时，自动将payload封装成chunk编码的方式。

所以框架的用户无需手动构建或者解析chunk。

stream类型仅对rpch-go实现，其他语言正处于开发中。

# 压测

除了三种语言实现的rpch外，还引入了golang的rpc标准库以及grpc框架来进行横向的对比。

测试案例选择简单的Add服务(两数相加)，本框架可以用两种IDL定义方式实现此Add服务：

> 第一种实现

```go
service Math{
	int32 Add(int32,int32)
}
```

不需要json序列化，数据全部用小端传输即可，效率更高。

> 第二种实现

```go
service Math{
	Response Add(Request)
}
message Response{
	int32 Result
}
message Request{
	int32 A
	int32 B
}
```

因为需要传输message这种复合结构，需要采用序列化，效率低，更能代表普遍的应用场景。google推出grpc只能使用此方式。显然第二种实现更贴近我们平时

的业务场景，所以对我们的框架压测除了采用第一种方式外，也测试了第二种实现。

在不同数量客户端连接下测量吞吐率和延时的时间，当客户端并发数小于等于500时，每个客户端发送10000个rpc请求。当客户端并发数大于500时，为了节省测

试用时，每个客户端发送1000请求。

采用reply-response同步请求方式，在未获取请求的响应之前，不允许再发送下一个请求。所有案例测试多次，取平均值。

测试环境：

+ 系统：Ubuntu 20.04。

+ 终端利用 ulimit -n 65535 命令，将允许打开的文件描述符个数改为最大。

+ CPU：AMD Ryzen 5 3550H 移动端。

+ 内存：16GB。

### 原始数据

rpch-c代表使用c语言实现的rpch框架，rpch-c(json)代表使用了第二种json序列化的方式。

不同框架在不同并发客户端数目下的吞吐率(每秒处理的请求数)：

|      | rpch-c | rpch-c(json) | rpch-go | rpch-go(json) | rpch-node | stdrpc | grpc-go |
| ---- | ------ | ------------ | ------- | ------------- | --------- | ------ | ------- |
| 1    | 9980   | 9320         | 11792   | 9355          | 1039      | 6993   | 3686    |
| 10   | 74239  | 72727        | 91491   | 78740         | 8702      | 71994  | 29420   |
| 100  | 178922 | 144928       | 148456  | 115380        | 12649     | 110803 | 37926   |
| 200  | 167940 | 130387       | 139860  | 111988        | 15759     | 107718 | 39118   |
| 300  | 158587 | 125697       | 134735  | 109601        | 17549     | 104102 | 39425   |
| 500  | 150299 | 119927       | 131144  | 107794        | 17370     | 101161 | 39538   |
| 1000 | 151604 | 120460       | 130371  | 111089        | 16420     | 102162 | 39757   |
| 2000 | 145041 | 1209575      | 129514  | 109922        | 15709     | 99789  | 37434   |
| 5000 | 143661 | 113254       | 123066  | 102303        | 14772     | 90283  | 36342   |

不同框架在不同并发客户端数目下的每个请求的延时(单位ms)：

|      | rpch-c  | rpch-c(json) | rpch-go | rpch-go(json) | rpch-node | stdrpc  | grpc-go  |
| ---- | ------- | ------------ | ------- | ------------- | --------- | ------- | -------- |
| 1    | 0.1002  | 0.1073       | 0.0848  | 0.1069        | 0.9628    | 0.143   | 0.2713   |
| 10   | 0.1347  | 0.1375       | 0.1093  | 0.127         | 1.1491    | 0.1389  | 0.3399   |
| 100  | 0.5589  | 0.69         | 0.6736  | 0.8667        | 7.9056    | 0.9025  | 2.6367   |
| 200  | 1.1909  | 1.5339       | 1.43    | 1.7859        | 12.691    | 1.8567  | 5.1127   |
| 300  | 1.8917  | 2.3867       | 2.2266  | 2.7372        | 17.0947   | 2.8818  | 7.6093   |
| 500  | 3.3267  | 4.1692       | 3.8126  | 4.6385        | 28.785    | 4.9426  | 12.6462  |
| 1000 | 6.5961  | 8.3015       | 7.6704  | 9.0018        | 60.903    | 9.7884  | 25.1527  |
| 2000 | 13.7892 | 16.5323      | 15.4424 | 18.1948       | 127.3164  | 20.0422 | 53.427   |
| 5000 | 34.8042 | 44.1485      | 40.6287 | 48.8744       | 338.4807  | 55.3812 | 137.5815 |

### 吞吐率

![image.png](https://s2.loli.net/2022/03/15/56AbshY1Rkuxm9L.png)

横坐标为客户端并发数，纵坐标为吞吐率即每秒处理的rpc请求数。吞吐率越高越好！

stdrpc代表golang标准库，grpc是google推出的grpc(本例使用Go语言实现rpc服务)框架，包含_json的为上述框架使用第二种实现(采用json序列化)的方式，其他

为使用第一种实现的方式。

rpch-c > rpch-go > rpch-c(json序列化) > rpch-go(json序列化) > stdrpc >> grpc > rpch-node

使用c语言开发的rpch框架效率最高，其次为golang实现。当采用json序列化后，效率会有一定的损失，但依旧优于golang的rpc标准库，grpc的性能很低，仅能

到达rpch-node的两倍。

### 延时

![image.png](https://s2.loli.net/2022/03/15/tczvKSjaNE54iVh.png)

横坐标为并发数，纵坐标为每个请求的延时，单位为毫秒。延时越低越好。

rpch-c < rpch-go < rpch-c(json序列化) < rpch-go(json序列化) < stdrpc << grpc < rpch-node

各框架服务都比较稳定，延时随并发数增长而线性增长，排名和吞吐率指标中一致，c语言的实现性能最优，nodejs实现最差。

# 安装与使用

两种安装方式：

+ 源码编译安装。

  ```shell
  # for linux
  git clone github.com/gufeijun/hgen
  cd hgen
  go build -o hgen main.go
  ```

  即可生成名叫hgen的可执行文件。

+ 二进制下载：[releases](https://github.com/gufeijun/hgen/releases)

请自行配置PATH。

使用：

```
Usage of hgen:
	hgen [options] <IDLfiles...>
options：
  -dir string
    	the dirpath where the generated source code files will be placed (default "gfj")
  -lang string
    	the target languege the IDL will be compliled to (default "c")
```

目前已支持go语言、c语言以及Nodejs，lang参数用于指定语言。dir参数用于指定生成的代码文件存放路径，默认为gfj。

